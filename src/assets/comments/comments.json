[
    {
        "id": "if",
        "body": {
            "title": "If",
            "grid_1": "El if nos permite realizar ejecuciones condicionales. <br><br> Un if tiene 2 partes: <ul> <li>La condición que se tiene que cumplir para que el bloque de código se ejecute.  El resultado de evaluar esta expresión puede ser True (verdadero) o False (falso). </li> <li> El bloque de código, que se ejecutará si se cumple la condición anterior (o sea si la evaluación de la expresión da True). </li> </ul><br> <br>Es muy importante tener en cuenta que la sentencia if, en Python, debe ir terminada por : y el bloque de código a ejecutar debe estar indentado. En otros lenguajes de programación, esta sintaxis puede variar.",
            "grid_2": "Un if puede tener varias condiciones que se deben combinar con las operaciones and o or. <br> <br> Es posible que no solo queramos hacer algo si una determinada condición se cumple, sino que además queramos hacer algo en caso que no se cumpla la condición. Para esto tenemos la cláusula else. El if se comporta como fue explicado antes, pero si tenemos un else, en el caso de que la condición del if no se cumpla, se ejecutará el bloque de código dentro del else. Ambos bloques de código (el del if y el del else) son excluyentes, esto quiere decir que si uno se ejecuta, el otro no lo hará.",
            "grid_3": "<h5>Operador ternario:</h5><br> El operador ternario o ternary operator es una herramienta muy potente que muchos lenguajes de programación tienen. Se trata de una cláusula if/else que se define en una sola línea y puede ser usado por ejemplo, dentro de un print(). Existen tres partes en un operador ternario, que son exactamente iguales a los que había en un if else. Tenemos la condición a evaluar, el código que se ejecuta si se cumple, y el código que se ejecuta si no se cumple. En este caso, tenemos los tres en la misma línea: [código si se cumple] if [condición] else [código si no se cumple]",
            "grid_4": "<h5>Elif:</h5>El if y el else nos permiten tener dos acciones distintas según se cumpla o no una condición. Pero podríamos tener más de dos condiciones en donde queremos realizar acciones diferentes. Para eso usamos la cláusula elif. Un elif siempre debe ir acompañado de un if, y se puede usar también de manera conjunta todo, el if con el elif y un else al final. Es muy importante notar que if y else solamente puede haber uno, mientras que elif puede haber varios. Con la cláusula elif podemos ejecutar tantos bloques de código distintos como queramos según la condición. Todos los bloques de código que tengamos en nuestros distintos elif son excluyentes entre sí y también con los del if y else. Esto quiere decir que solo se ejecutará un bloque de código de todos los que haya.  Cabe aclarar que una vez que una condición se cumple y se ejecuta ese bloque de código, los elif/else que haya después de ese que se ejecutó no se evalúan, y se continúa directamente con el código que sigue luego de la estructura (si hubiera)."
        }
    },
    {
        "id": "while",
        "body":{
            "title": "While",
            "grid_1": "El uso del while nos permite ejecutar una sección de código repetidas veces. El código se ejecutará mientras una condición determinada se cumpla, o sea, mientras que se evalúe como True. Cuando se deje de cumplir, se saldrá del bucle y se continuará la ejecución normal. Llamaremos iteración a una ejecución completa del bloque de código dentro del while.",
            "grid_2": "Cabe destacar que existen dos tipos de bucles, los que tienen un número de iteraciones no definidas, y los que tienen un número de iteraciones definidas. El while estaría dentro del primer tipo. <br> <br>Hay que tener cuidado al pensar las condiciones de los while, ya que un mal uso del mismo puede dar lugar a bucles infinitos y problemas. Si por ejemplo iteramos hasta que cierta variable llegue a un valor, pero nunca actualizamos el valor de esa variable, nunca saldremos del while.",
            "grid_3": "",
            "grid_4": ""
        }
    },
    {
        "id": "def",
        "body":{
            "title": "Funciones",
            "grid_1": "<h5>Modularización:</h5> En programación un módulo corresponde a alguna de las partes en la que un determinado problema fue dividido, es decir que un módulo resuelve alguno de los subproblemas que conforman al problema original. Un módulo puede ser pensado como una parte de un programa. Se debe tener en cuenta que un módulo no es estrictamente un único subprograma sino que también puede ser un conjunto de varios de ellos. La modularización en definitiva es construir un programa basándose en módulos independientes. <br> <br> La pieza fundamental para la modularización en Python se denomina función. Una función nos permite modularizar un programa. <br> <br> Existen funciones nativas que vienen con Python o agrupadas en módulos según distintas especialidades, como las funciones matemáticas en math, para recibir datos del usuario, pero al igual que en otros lenguajes de programación, también podemos definir nuestras propias funciones. Para ello hacemos uso de la palabra reservada def.",
            "grid_2": "La palabra clave def introduce una definición de función. Debe ir seguida del nombre de la función y de la lista de parámetros formales entre paréntesis. Las instrucciones que forman el cuerpo de la función comienzan en la línea siguiente y deben estar indentadas. <br> <br> Una de las utilidades de las funciones es que te permiten reutilizar código, si tenemos un fragmento de código usado en muchos sitios, la mejor solución sería pasarlo a una función. Esto nos evitaría tener código repetido (simplemente llamaríamos a la función donde lo necesitemos), y en caso de necesitar modificar ese código, es mucho más fácil ya que bastaría con cambiar solamente la función.",
            "grid_3": "Una función consta de: <br> <ul> <li><b> Un nombre: </b>preferentemente el nombre debe hacer referencia a lo que devuelve o lo que hace la función, para más claridad en el código.</li> <li> <b>Lista de parámetros de entrada:</b> Un parámetro es una variable utilizada para recibir valores de entrada en una función. La lista de parámetros consiste en una lista separada por comas que contiene las declaraciones de los parámetros recibidos por la función al ser invocada. Una función puede no tener parámetros de entrada. Los parámetros que se utilizan en la definición de funciones se denominan formales porque representan cualesquiera argumentos concretos con los que puedan invocarse (valores literales, variables o expresiones). Los parámetros que se utilizan para invocar una función se denominan reales.</li> <li> <b>Acciones y declaraciones:</b> Dentro del cuerpo de una función se espera encontrar declaraciones de variables, necesarias para alcanzar el objetivo de la función. Estas variables declaradas dentro de la función se denominan variables locales, una variable es local dentro del bloque de programa, en este caso una función, en la cual es declarada. También se espera encontrar acciones y estructuras de control para que la función pueda realizar lo necesario. </li> <li> <b>Parámetros de salida:</b> son las variables o valores que devolverá la función. En Python, una función puede devolver más de un valor. </li> </ul>",
            "grid_4": "<h5>Sentencia return:</h5> El uso de la sentencia return permite realizar dos cosas: <br> <ul><li>Salir de la función y transferir la ejecución de vuelta a donde se realizó la llamada. El código que esté luego del return (dentro de la función) no se ejecutará, por eso solo llamamos al return cuando finalizamos lo que queríamos hacer en la función.</li> <li>Devolver uno o varios parámetros, fruto de la ejecución de la función. </li> </ul> Si llamamos al return sin valores de retorno, se retorna None. Lo mismo sucede si se llega al final de la función y no se encuentra un return.  </ul>"
        }
    },
    {
        "id": "listas",
        "body": {
            "title": "Listas",
            "grid_1": "Las listas en Python son uno de los tipos o estructuras de datos más versátiles del lenguaje, ya que permiten almacenar un conjunto arbitrario de datos. Es decir, podemos guardar en ellas prácticamente lo que sea. Para crear una lista usamos los corchetes [] o el método list().<br><br> <h5>Características:</h5> <ul> <li> Son ordenadas, mantienen el orden en el que han sido definidas.</li> <li> Pueden estar compuestas por tipos arbitrarios. </li> <li> Pueden ser indexadas con [i]. </li> <li> Se pueden anidar, es decir, meter una lista dentro de otra. </li> <li> Son mutables, ya que sus elementos pueden ser modificados. </li> <li> Son dinámicas, ya que se pueden añadir o eliminar elementos.</li> </ul>",
            "grid_2": "Para acceder a los elementos de una lista, podemos usar los corchetes y un índice (posición a la que queremos acceder). Los índices de una lista van de 0 a n-1, siendo n el tamaño de la lista. Se puede también acceder al último elemento usando el índice [-1]. También es posible crear sublistas más pequeñas de una más grande. Para ello debemos de usar : entre corchetes, indicando a la izquierda el valor de inicio, y a la izquierda el valor final que no está incluido. Por lo tanto [0:2] creará una lista con los elementos [0] y [1] de la original.",
            "grid_3": "<h5>Operaciones sobre listas:</h5> <ul> <li> <b>append(x):</b> Añade el elemento x al final de la lista. </li> <li> <b>insert(i, x):</b> Añade el elemento x en una posición determinada por i. </li> <li> <b>remove(x):</b> Elimina el elemento x de la lista. </li> <li> <b>pop(i) o pop():</b> Elimina un elemento de la lista en una posición determinada por i. Si no se proporciona una posición, se elimina el último elemento de la lista. Además de eliminarlo, devuelve ese elemento que se eliminó.  </li> <li> <b>clear():</b> Elimina todos los elementos de la lista. </li> <li> <b>index(x):</b> Devuelve el índice del elemento x. </li> <li> <b>count(x):</b> Devuelve el número de veces que aparece el elemento x. </li> <li> <b>sort():</b> Ordena la lista. </li> <li> <b>reverse():</b> Invierte el orden de la lista. </li> </ul>",
            "grid_4": ""
        }
    },
    {
        "id": "nativas",
        "body": {
            "title": "Funciones nativas de Python",
            "grid_1": "<b>input()</b> <br>Si el argumento (cadena de caracteres) está presente, se escribe en la salida estándar sin una nueva línea final. Luego, la función lee una línea de la entrada, la convierte en una cadena y la devuelve. Sirve para pedirle datos al usuario. <br> <br> <b>round()</b><br> Puede recibir dos parámetros numéricos. Es una función propia de python. El primer parámetro es el número que se quiere redondear y el segundo es la cantidad de dígitos de precisión. Devuelve al primer parámetro redondeado a la cantidad de dígitos de precisión. Si se omite el segundo parámetro, devuelve el entero más cercano al primer parámetro. <br> <br> <b>len()</b><br> Es una función propia de python. Devuelve la longitud (cantidad de items) del objeto que recibe. El objeto puede ser una secuencia (string, bytes, tuplas, lista o rango) o una colección (diccionario, set). <br> <br> <b>print()</b><br> Imprime su argumento en el archivo de flujo de texto. Por default, el caracter final será un enter (\\n), con el parámetro 'end=' se puede cambiar ese caracter final. <br> <br> <b>pow()</b><br> Devuelve el primer parámetro elevado al segundo parámetro. Esta función es equivalente a hacer la operación base**exponente.",
            "grid_2": "<b>int()/float()</b> Retorna el valor de su parámetro como un entero/número real con decimales.",
            "grid_3": "<h5>Módulo math:</h5> Este módulo proporciona acceso a las funciones matemáticas. <br> <br> <b>sqrt()</b> Recibe un número como parámetro. Devuelve la raíz cuadrada del número que recibe. <br> <br> <b>log10()</b> Recibe un número como parámetro. Devuelve el logaritmo en base 10 del número que recibe. <br> <br> <b>asin()</b> Recibe un número como parámetro. Devuelve el arcoseno del número que recibe, en radianes. El resultado está entre -pi/2 y pi/2.",
            "grid_4": ""

        }
    },
    {
        "id": "for",
        "body": {
            "title": "For",
            "grid_1": "El for es un tipo de bucle, un poco diferente al bucle while. La principal es que el número de iteraciones de un for está definido de antemano, mientras que en un while no. La diferencia principal con respecto al while es en la condición. Mientras que en el while la condición era evaluada en cada iteración para decidir si volver a ejecutar o no el código, en el for no existe tal condición, sino un iterable que define las veces que se ejecutará el código. En Python se puede iterar casi todo. <br> <br> Para entender al cien por cien los bucles for, y cómo Python fue diseñado como lenguaje de programación, es muy importante entender los conceptos de iterables e iteradores: <ul> <li>Los iterables son aquellos objetos que, como su nombre indica, pueden ser iterados, lo que dicho de otra forma es, que puedan ser indexados. Si piensas en un array (o una lista en Python), podemos indexarlo con lista[1] por ejemplo, por lo que sería un iterable. </li> <li>Los iteradores son objetos que hacen referencia a un elemento, y que tienen un método next que permite hacer referencia al siguiente elemento. </li></ul> Sabiendo esto, lo primero que tenemos que tener claro es que en un for, lo que va después del in deberá ser siempre un iterable.",
            "grid_3": "<h5>For anidados</h5> Es posible anidar los for, es decir, meter uno dentro de otro. Esto puede ser muy útil si queremos iterar algún objeto que en cada elemento, tiene a su vez otra clase iterable. Podemos tener por ejemplo, una lista de listas, una especie de matriz. <br> <br> <h5>Range</h5> El range() genera una secuencia de números que van desde 0 por defecto hasta el número que se pasa como parámetro menos 1. En realidad, se pueden pasar hasta tres parámetros separados por coma, donde el primer es el inicio de la secuencia, el segundo el final y el tercero el salto que se desea entre números. Por defecto se empieza en 0 y el salto es de 1. Se pueden generar también secuencias inversas, empezando por un número mayor y terminando en uno menor, pero para ello el salto deberá ser negativo.",
            "grid_2": "",
            "grid_4": ""
        }
    },
    {
        "id": "tuplas",
        "body": {
            "title": "Tuplas",
            "grid_1": "Las tuplas son secuencias inmutables (no se pueden cambiar o actualizar una vez declaradas), que suelen utilizarse para almacenar colecciones de datos heterogéneos. Las tuplas también se utilizan para casos en los que se necesita una secuencia inmutable de datos homogéneos. <br> <br> Para crear una tupla usamos los paréntesis () o el método tuple(). <br> <br> Al igual que las listas, las tuplas también pueden ser anidadas, eso quiere decir que podemos tener una tupla dentro de otra. <br> <br> Dependiendo de lo que queramos hacer, las tuplas pueden ser más rápidas ya que son inmutables. <br> Podemos también convertir una lista en una tupla utilizando la función tuple() y enviándole como parámetro la lista que queremos transformar. <br> <br> Una tupla puede ser iterada de la misma forma que se itera una lista y también pueden indexarse. <br> <br> <h5> Métodos de las tuplas: </h5> <ul> <li> <b>count(x):</b> Devuelve el número de veces que aparece x en la tupla. </li> <li> <b>index(x):</b> Devuelve el índice de la primera aparición de x en la tupla. </li> </ul>",
            "grid_3": "",
            "grid_4": "",
            "grid_2": ""
        }
    },
    {
        "id": "conjuntos",
        "body": {
            "title": "Conjuntos",
            "grid_1": "Los conjuntos en Python (también llamados Set) son una estructura de datos utilizada para almacenar elementos de una manera similar a las listas, pero con algunas diferencias. <br> <br> Los conjuntos son colecciones no ordenadas de elementos únicos. Esto significa que no pueden tener elementos duplicados. Son además desordenados, lo que significa que no mantienen el orden en el cual son declarados. Por último, sus elementos deben ser inmutables. <br> <br> Para crear un conjunto usamos llaves {} o el método set(). <br> <br> Los conjuntos son muy útiles para realizar operaciones matemáticas como unión, intersección, diferencia y diferencia simétrica. <br> <br> Los conjuntos no soportan indexación, por lo que no podemos acceder a un elemento específico de un conjunto.",
            "grid_3": "<h5> Métodos de los conjuntos: </h5> <ul> <li> <b>add(x):</b> Agrega el elemento x al conjunto. </li> <li> <b>remove(x):</b> Elimina el elemento x del conjunto. </li> <li> <b>discard(x):</b> Elimina el elemento x del conjunto, si está presente. </li> <li> <b>pop():</b> Elimina un elemento aleatorio del conjunto y lo devuelve. </li> <li> <b>clear():</b> Elimina todos los elementos del conjunto. </li> <li> <b>union(x):</b> Devuelve un nuevo conjunto con todos los elementos de x y del conjunto. </li> <li> <b>intersection(x):</b> Devuelve un nuevo conjunto con los elementos que están en x y en el conjunto. </li> <li> <b>difference(x):</b> Devuelve un nuevo conjunto con los elementos que están en el conjunto pero no en x. </li> <li> <b>symmetric_difference(x):</b> Devuelve un nuevo conjunto con los elementos que están en el conjunto o en x, pero no en ambos. </li> </ul> Estos últimos 4 métodos pueden ser usados para hacer dicha operación entre dos o más conjuntos.",
            "grid_2": "",
            "grid_4": ""
        }
    },
    {
        "id": "diccionarios",
        "body": {
            "title": "Diccionarios",
            "grid_1": "Un diccionario en Python es una colección de elementos, donde cada uno tiene una llave key y un valor value. Los diccionarios se pueden crear con llaves {} separando con una coma cada par ´key: value´. También se puede crear un diccionario usando el constructor dict(). <br> <br> Los diccionarios son colecciones no ordenadas, lo que significa que no mantienen el orden en el cual son declarados. <br> <br> Son mutables, lo que significa que sus elementos pueden ser modificados. <br> <br> Son muy útiles para almacenar información que se relaciona con una llave, como por ejemplo, un diccionario de contactos, donde la llave es el nombre de la persona y el valor es su número de teléfono. <br> <br> Son estructuras indexadas, pero la forma de acceso es diferente a las listas ya que estos no son ordenados. La forma de acceso es a través de la key. También son anidados, un diccionario puede contener otro.",
            "grid_2": "Para acceder a sus elementos se puede usar los corchetes [key] o también la función get(key). Para agregar un elementos simplemente usamos [key] y asignamos el valor que queremos. Si el valor de la key ya existe, su value se reemplaza por el nuevo. Si la key no existía en el diccionario, se crea un nuevo par key: value.",
            "grid_3": "<h5> Metodos de los diccionarios: </h5> <ul> <li> <b>clear():</b> Elimina todos los elementos del diccionario. </li> <li> <b>copy():</b> Devuelve una copia del diccionario. </li> <li> <b>get(key):</b> Devuelve el valor de la key. </li> <li> <b>items():</b> Devuelve una vista de los pares key: value. </li> <li> <b>keys():</b> Devuelve una vista de las keys. </li> <li> <b>pop(key):</b> Elimina la key y devuelve su value. </li> <li> <b>popitem():</b> Elimina el último par key: value insertado. </li> <li> <b>update(x):</b> Actualiza el diccionario con los pares key: value de x. </li> <li> <b>values():</b> Devuelve una vista de los values. </li> </ul>",
            "grid_4": ""
        }
    }
]