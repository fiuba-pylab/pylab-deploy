{"version":3,"sources":["node_modules/@angular/core/fesm2022/rxjs-interop.mjs","node_modules/@ngrx/store/fesm2022/ngrx-store.mjs","src/app/ngrx/actions.ts"],"sourcesContent":["/**\n * @license Angular v17.3.8\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, ɵRuntimeError, ɵgetOutputDestroyRef, Injector, effect, untracked, assertNotInReactiveContext, signal, computed } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @developerPreview\n */\nfunction takeUntilDestroyed(destroyRef) {\n  if (!destroyRef) {\n    assertInInjectionContext(takeUntilDestroyed);\n    destroyRef = inject(DestroyRef);\n  }\n  const destroyed$ = new Observable(observer => {\n    const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n    return unregisterFn;\n  });\n  return source => {\n    return source.pipe(takeUntil(destroyed$));\n  };\n}\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef {\n  constructor(source) {\n    this.source = source;\n    this.destroyed = false;\n    this.destroyRef = inject(DestroyRef);\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n    });\n  }\n  subscribe(callbackFn) {\n    if (this.destroyed) {\n      throw new ɵRuntimeError(953 /* ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode && 'Unexpected subscription to destroyed `OutputRef`. ' + 'The owning directive/component is destroyed.');\n    }\n    // Stop yielding more values when the directive/component is already destroyed.\n    const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n      next: value => callbackFn(value)\n    });\n    return {\n      unsubscribe: () => subscription.unsubscribe()\n    };\n  }\n}\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n *\n * @developerPreview\n */\nfunction outputFromObservable(observable, opts) {\n  ngDevMode && assertInInjectionContext(outputFromObservable);\n  return new OutputFromObservableRef(observable);\n}\n\n/**\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\n * to an observable.\n *\n * You can subscribe to the output via `Observable.subscribe` then.\n *\n * @developerPreview\n */\nfunction outputToObservable(ref) {\n  const destroyRef = ɵgetOutputDestroyRef(ref);\n  return new Observable(observer => {\n    // Complete the observable upon directive/component destroy.\n    // Note: May be `undefined` if an `EventEmitter` is declared outside\n    // of an injection context.\n    destroyRef?.onDestroy(() => observer.complete());\n    const subscription = ref.subscribe(v => observer.next(v));\n    return () => subscription.unsubscribe();\n  });\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nfunction toObservable(source, options) {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject(1);\n  const watcher = effect(() => {\n    let value;\n    try {\n      value = source();\n    } catch (err) {\n      untracked(() => subject.error(err));\n      return;\n    }\n    untracked(() => subject.next(value));\n  }, {\n    injector,\n    manualCleanup: true\n  });\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n  return subject.asObservable();\n}\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](/guide/dependency-injection-context) is destroyed. For example, when `toSignal` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nfunction toSignal(source, options) {\n  ngDevMode && assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' + 'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\n  const requiresCleanup = !options?.manualCleanup;\n  requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n  const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n  // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n  // the same - the returned signal gives values of type `T`.\n  let state;\n  if (options?.requireSync) {\n    // Initially the signal is in a `NoValue` state.\n    state = signal({\n      kind: 0 /* StateKind.NoValue */\n    });\n  } else {\n    // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n    state = signal({\n      kind: 1 /* StateKind.Value */,\n      value: options?.initialValue\n    });\n  }\n  // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n  // this, we would subscribe to the observable outside of the current reactive context, avoiding\n  // that side-effect signal reads/writes are attribute to the current consumer. The current\n  // consumer only needs to be notified when the `state` signal changes through the observable\n  // subscription. Additional context (related to async pipe):\n  // https://github.com/angular/angular/pull/50522.\n  const sub = source.subscribe({\n    next: value => state.set({\n      kind: 1 /* StateKind.Value */,\n      value\n    }),\n    error: error => {\n      if (options?.rejectErrors) {\n        // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes\n        // the error to end up as an uncaught exception.\n        throw error;\n      }\n      state.set({\n        kind: 2 /* StateKind.Error */,\n        error\n      });\n    }\n    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n    // \"complete\".\n  });\n  if (ngDevMode && options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\n    throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n  }\n  // Unsubscribe when the current context is destroyed, if requested.\n  cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n  // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n  // to either values or errors.\n  return computed(() => {\n    const current = state();\n    switch (current.kind) {\n      case 1 /* StateKind.Value */:\n        return current.value;\n      case 2 /* StateKind.Error */:\n        throw current.error;\n      case 0 /* StateKind.NoValue */:\n        // This shouldn't really happen because the error is thrown on creation.\n        // TODO(alxhub): use a RuntimeError when we finalize the error semantics\n        throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n  });\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { outputFromObservable, outputToObservable, takeUntilDestroyed, toObservable, toSignal };\n","import * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, Inject, computed, isDevMode, inject, makeEnvironmentProviders, ENVIRONMENT_INITIALIZER, NgModule, Optional } from '@angular/core';\nimport { BehaviorSubject, Observable, Subject, queueScheduler } from 'rxjs';\nimport { observeOn, withLatestFrom, scan, pluck, map, distinctUntilChanged } from 'rxjs/operators';\nimport { toSignal } from '@angular/core/rxjs-interop';\nconst REGISTERED_ACTION_TYPES = {};\nfunction resetRegisteredActionTypes() {\n  for (const key of Object.keys(REGISTERED_ACTION_TYPES)) {\n    delete REGISTERED_ACTION_TYPES[key];\n  }\n}\n\n/**\n * @description\n * Creates a configured `Creator` function that, when called, returns an object in the shape of the `Action` interface.\n *\n * Action creators reduce the explicitness of class-based action creators.\n *\n * @param type Describes the action that will be dispatched\n * @param config Additional metadata needed for the handling of the action.  See {@link createAction#usage-notes Usage Notes}.\n *\n * @usageNotes\n *\n * **Declaring an action creator**\n *\n * Without additional metadata:\n * ```ts\n * export const increment = createAction('[Counter] Increment');\n * ```\n * With additional metadata:\n * ```ts\n * export const loginSuccess = createAction(\n *   '[Auth/API] Login Success',\n *   props<{ user: User }>()\n * );\n * ```\n * With a function:\n * ```ts\n * export const loginSuccess = createAction(\n *   '[Auth/API] Login Success',\n *   (response: Response) => response.user\n * );\n * ```\n *\n * **Dispatching an action**\n *\n * Without additional metadata:\n * ```ts\n * store.dispatch(increment());\n * ```\n * With additional metadata:\n * ```ts\n * store.dispatch(loginSuccess({ user: newUser }));\n * ```\n *\n * **Referencing an action in a reducer**\n *\n * Using a switch statement:\n * ```ts\n * switch (action.type) {\n *   // ...\n *   case AuthApiActions.loginSuccess.type: {\n *     return {\n *       ...state,\n *       user: action.user\n *     };\n *   }\n * }\n * ```\n * Using a reducer creator:\n * ```ts\n * on(AuthApiActions.loginSuccess, (state, { user }) => ({ ...state, user }))\n * ```\n *\n *  **Referencing an action in an effect**\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(AuthApiActions.loginSuccess),\n *     // ...\n *   )\n * );\n * ```\n */\nfunction createAction(type, config) {\n  REGISTERED_ACTION_TYPES[type] = (REGISTERED_ACTION_TYPES[type] || 0) + 1;\n  if (typeof config === 'function') {\n    return defineType(type, (...args) => ({\n      ...config(...args),\n      type\n    }));\n  }\n  const as = config ? config._as : 'empty';\n  switch (as) {\n    case 'empty':\n      return defineType(type, () => ({\n        type\n      }));\n    case 'props':\n      return defineType(type, props => ({\n        ...props,\n        type\n      }));\n    default:\n      throw new Error('Unexpected config.');\n  }\n}\nfunction props() {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return {\n    _as: 'props',\n    _p: undefined\n  };\n}\nfunction union(creators) {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return undefined;\n}\nfunction defineType(type, creator) {\n  return Object.defineProperty(creator, 'type', {\n    value: type,\n    writable: false\n  });\n}\nfunction capitalize(text) {\n  return text.charAt(0).toUpperCase() + text.substring(1);\n}\nfunction uncapitalize(text) {\n  return text.charAt(0).toLowerCase() + text.substring(1);\n}\n\n/**\n * @description\n * A function that creates a group of action creators with the same source.\n *\n * @param config An object that contains a source and dictionary of events.\n * An event is a key-value pair of an event name and event props.\n * @returns A dictionary of action creators.\n * The name of each action creator is created by camel casing the event name.\n * The type of each action is created using the \"[Source] Event Name\" pattern.\n *\n * @usageNotes\n *\n * ```ts\n * const authApiActions = createActionGroup({\n *   source: 'Auth API',\n *   events: {\n *     // defining events with payload using the `props` function\n *     'Login Success': props<{ userId: number; token: string }>(),\n *     'Login Failure': props<{ error: string }>(),\n *\n *     // defining an event without payload using the `emptyProps` function\n *     'Logout Success': emptyProps(),\n *\n *     // defining an event with payload using the props factory\n *     'Logout Failure': (error: Error) => ({ error }),\n *   },\n * });\n *\n * // action type: \"[Auth API] Login Success\"\n * authApiActions.loginSuccess({ userId: 10, token: 'ngrx' });\n *\n * // action type: \"[Auth API] Login Failure\"\n * authApiActions.loginFailure({ error: 'Login Failure!' });\n *\n * // action type: \"[Auth API] Logout Success\"\n * authApiActions.logoutSuccess();\n *\n * // action type: \"[Auth API] Logout Failure\";\n * authApiActions.logoutFailure(new Error('Logout Failure!'));\n * ```\n */\nfunction createActionGroup(config) {\n  const {\n    source,\n    events\n  } = config;\n  return Object.keys(events).reduce((actionGroup, eventName) => ({\n    ...actionGroup,\n    [toActionName(eventName)]: createAction(toActionType(source, eventName), events[eventName])\n  }), {});\n}\nfunction emptyProps() {\n  return props();\n}\nfunction toActionName(eventName) {\n  return eventName.trim().split(' ').map((word, i) => i === 0 ? uncapitalize(word) : capitalize(word)).join('');\n}\nfunction toActionType(source, eventName) {\n  return `[${source}] ${eventName}`;\n}\nconst INIT = '@ngrx/store/init';\nlet ActionsSubject = /*#__PURE__*/(() => {\n  class ActionsSubject extends BehaviorSubject {\n    constructor() {\n      super({\n        type: INIT\n      });\n    }\n    next(action) {\n      if (typeof action === 'function') {\n        throw new TypeError(`\n        Dispatch expected an object, instead it received a function.\n        If you're using the createAction function, make sure to invoke the function\n        before dispatching the action. For example, someAction should be someAction().`);\n      } else if (typeof action === 'undefined') {\n        throw new TypeError(`Actions must be objects`);\n      } else if (typeof action.type === 'undefined') {\n        throw new TypeError(`Actions must have a type property`);\n      }\n      super.next(action);\n    }\n    complete() {\n      /* noop */\n    }\n    ngOnDestroy() {\n      super.complete();\n    }\n    /** @nocollapse */\n    static {\n      this.ɵfac = function ActionsSubject_Factory(t) {\n        return new (t || ActionsSubject)();\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n        token: ActionsSubject,\n        factory: ActionsSubject.ɵfac\n      });\n    }\n  }\n  return ActionsSubject;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ACTIONS_SUBJECT_PROVIDERS = [ActionsSubject];\nconst _ROOT_STORE_GUARD = new InjectionToken('@ngrx/store Internal Root Guard');\nconst _INITIAL_STATE = new InjectionToken('@ngrx/store Internal Initial State');\nconst INITIAL_STATE = new InjectionToken('@ngrx/store Initial State');\nconst REDUCER_FACTORY = new InjectionToken('@ngrx/store Reducer Factory');\nconst _REDUCER_FACTORY = new InjectionToken('@ngrx/store Internal Reducer Factory Provider');\nconst INITIAL_REDUCERS = new InjectionToken('@ngrx/store Initial Reducers');\nconst _INITIAL_REDUCERS = new InjectionToken('@ngrx/store Internal Initial Reducers');\nconst STORE_FEATURES = new InjectionToken('@ngrx/store Store Features');\nconst _STORE_REDUCERS = new InjectionToken('@ngrx/store Internal Store Reducers');\nconst _FEATURE_REDUCERS = new InjectionToken('@ngrx/store Internal Feature Reducers');\nconst _FEATURE_CONFIGS = new InjectionToken('@ngrx/store Internal Feature Configs');\nconst _STORE_FEATURES = new InjectionToken('@ngrx/store Internal Store Features');\nconst _FEATURE_REDUCERS_TOKEN = new InjectionToken('@ngrx/store Internal Feature Reducers Token');\nconst FEATURE_REDUCERS = new InjectionToken('@ngrx/store Feature Reducers');\n/**\n * User-defined meta reducers from StoreModule.forRoot()\n */\nconst USER_PROVIDED_META_REDUCERS = new InjectionToken('@ngrx/store User Provided Meta Reducers');\n/**\n * Meta reducers defined either internally by @ngrx/store or by library authors\n */\nconst META_REDUCERS = new InjectionToken('@ngrx/store Meta Reducers');\n/**\n * Concats the user provided meta reducers and the meta reducers provided on the multi\n * injection token\n */\nconst _RESOLVED_META_REDUCERS = new InjectionToken('@ngrx/store Internal Resolved Meta Reducers');\n/**\n * Runtime checks defined by the user via an InjectionToken\n * Defaults to `_USER_RUNTIME_CHECKS`\n */\nconst USER_RUNTIME_CHECKS = new InjectionToken('@ngrx/store User Runtime Checks Config');\n/**\n * Runtime checks defined by the user via forRoot()\n */\nconst _USER_RUNTIME_CHECKS = new InjectionToken('@ngrx/store Internal User Runtime Checks Config');\n/**\n * Runtime checks currently in use\n */\nconst ACTIVE_RUNTIME_CHECKS = new InjectionToken('@ngrx/store Internal Runtime Checks');\nconst _ACTION_TYPE_UNIQUENESS_CHECK = new InjectionToken('@ngrx/store Check if Action types are unique');\n/**\n * InjectionToken that registers the global Store.\n * Mainly used to provide a hook that can be injected\n * to ensure the root state is loaded before something\n * that depends on it.\n */\nconst ROOT_STORE_PROVIDER = new InjectionToken('@ngrx/store Root Store Provider');\n/**\n * InjectionToken that registers feature states.\n * Mainly used to provide a hook that can be injected\n * to ensure feature state is loaded before something\n * that depends on it.\n */\nconst FEATURE_STATE_PROVIDER = new InjectionToken('@ngrx/store Feature State Provider');\n\n/**\n * @description\n * Combines reducers for individual features into a single reducer.\n *\n * You can use this function to delegate handling of state transitions to multiple reducers, each acting on their\n * own sub-state within the root state.\n *\n * @param reducers An object mapping keys of the root state to their corresponding feature reducer.\n * @param initialState Provides a state value if the current state is `undefined`, as it is initially.\n * @returns A reducer function.\n *\n * @usageNotes\n *\n * **Example combining two feature reducers into one \"root\" reducer**\n *\n * ```ts\n * export const reducer = combineReducers({\n *   featureA: featureAReducer,\n *   featureB: featureBReducer\n * });\n * ```\n *\n * You can also override the initial states of the sub-features:\n * ```ts\n * export const reducer = combineReducers({\n *   featureA: featureAReducer,\n *   featureB: featureBReducer\n * }, {\n *   featureA: { counterA: 13 },\n *   featureB: { counterB: 37 }\n * });\n * ```\n */\nfunction combineReducers(reducers, initialState = {}) {\n  const reducerKeys = Object.keys(reducers);\n  const finalReducers = {};\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i];\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers);\n  return function combination(state, action) {\n    state = state === undefined ? initialState : state;\n    let hasChanged = false;\n    const nextState = {};\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i];\n      const reducer = finalReducers[key];\n      const previousStateForKey = state[key];\n      const nextStateForKey = reducer(previousStateForKey, action);\n      nextState[key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    return hasChanged ? nextState : state;\n  };\n}\nfunction omit(object, keyToRemove) {\n  return Object.keys(object).filter(key => key !== keyToRemove).reduce((result, key) => Object.assign(result, {\n    [key]: object[key]\n  }), {});\n}\nfunction compose(...functions) {\n  return function (arg) {\n    if (functions.length === 0) {\n      return arg;\n    }\n    const last = functions[functions.length - 1];\n    const rest = functions.slice(0, -1);\n    return rest.reduceRight((composed, fn) => fn(composed), last(arg));\n  };\n}\nfunction createReducerFactory(reducerFactory, metaReducers) {\n  if (Array.isArray(metaReducers) && metaReducers.length > 0) {\n    reducerFactory = compose.apply(null, [...metaReducers, reducerFactory]);\n  }\n  return (reducers, initialState) => {\n    const reducer = reducerFactory(reducers);\n    return (state, action) => {\n      state = state === undefined ? initialState : state;\n      return reducer(state, action);\n    };\n  };\n}\nfunction createFeatureReducerFactory(metaReducers) {\n  const reducerFactory = Array.isArray(metaReducers) && metaReducers.length > 0 ? compose(...metaReducers) : r => r;\n  return (reducer, initialState) => {\n    reducer = reducerFactory(reducer);\n    return (state, action) => {\n      state = state === undefined ? initialState : state;\n      return reducer(state, action);\n    };\n  };\n}\nclass ReducerObservable extends Observable {}\nclass ReducerManagerDispatcher extends ActionsSubject {}\nconst UPDATE = '@ngrx/store/update-reducers';\nlet ReducerManager = /*#__PURE__*/(() => {\n  class ReducerManager extends BehaviorSubject {\n    get currentReducers() {\n      return this.reducers;\n    }\n    constructor(dispatcher, initialState, reducers, reducerFactory) {\n      super(reducerFactory(reducers, initialState));\n      this.dispatcher = dispatcher;\n      this.initialState = initialState;\n      this.reducers = reducers;\n      this.reducerFactory = reducerFactory;\n    }\n    addFeature(feature) {\n      this.addFeatures([feature]);\n    }\n    addFeatures(features) {\n      const reducers = features.reduce((reducerDict, {\n        reducers,\n        reducerFactory,\n        metaReducers,\n        initialState,\n        key\n      }) => {\n        const reducer = typeof reducers === 'function' ? createFeatureReducerFactory(metaReducers)(reducers, initialState) : createReducerFactory(reducerFactory, metaReducers)(reducers, initialState);\n        reducerDict[key] = reducer;\n        return reducerDict;\n      }, {});\n      this.addReducers(reducers);\n    }\n    removeFeature(feature) {\n      this.removeFeatures([feature]);\n    }\n    removeFeatures(features) {\n      this.removeReducers(features.map(p => p.key));\n    }\n    addReducer(key, reducer) {\n      this.addReducers({\n        [key]: reducer\n      });\n    }\n    addReducers(reducers) {\n      this.reducers = {\n        ...this.reducers,\n        ...reducers\n      };\n      this.updateReducers(Object.keys(reducers));\n    }\n    removeReducer(featureKey) {\n      this.removeReducers([featureKey]);\n    }\n    removeReducers(featureKeys) {\n      featureKeys.forEach(key => {\n        this.reducers = omit(this.reducers, key) /*TODO(#823)*/;\n      });\n      this.updateReducers(featureKeys);\n    }\n    updateReducers(featureKeys) {\n      this.next(this.reducerFactory(this.reducers, this.initialState));\n      this.dispatcher.next({\n        type: UPDATE,\n        features: featureKeys\n      });\n    }\n    ngOnDestroy() {\n      this.complete();\n    }\n    /** @nocollapse */\n    static {\n      this.ɵfac = function ReducerManager_Factory(t) {\n        return new (t || ReducerManager)(i0.ɵɵinject(ReducerManagerDispatcher), i0.ɵɵinject(INITIAL_STATE), i0.ɵɵinject(INITIAL_REDUCERS), i0.ɵɵinject(REDUCER_FACTORY));\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n        token: ReducerManager,\n        factory: ReducerManager.ɵfac\n      });\n    }\n  }\n  return ReducerManager;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst REDUCER_MANAGER_PROVIDERS = [ReducerManager, {\n  provide: ReducerObservable,\n  useExisting: ReducerManager\n}, {\n  provide: ReducerManagerDispatcher,\n  useExisting: ActionsSubject\n}];\nlet ScannedActionsSubject = /*#__PURE__*/(() => {\n  class ScannedActionsSubject extends Subject {\n    ngOnDestroy() {\n      this.complete();\n    }\n    /** @nocollapse */\n    static {\n      this.ɵfac = /* @__PURE__ */(() => {\n        let ɵScannedActionsSubject_BaseFactory;\n        return function ScannedActionsSubject_Factory(t) {\n          return (ɵScannedActionsSubject_BaseFactory || (ɵScannedActionsSubject_BaseFactory = i0.ɵɵgetInheritedFactory(ScannedActionsSubject)))(t || ScannedActionsSubject);\n        };\n      })();\n    }\n    /** @nocollapse */\n    static {\n      this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n        token: ScannedActionsSubject,\n        factory: ScannedActionsSubject.ɵfac\n      });\n    }\n  }\n  return ScannedActionsSubject;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst SCANNED_ACTIONS_SUBJECT_PROVIDERS = [ScannedActionsSubject];\nclass StateObservable extends Observable {}\nlet State = /*#__PURE__*/(() => {\n  class State extends BehaviorSubject {\n    static {\n      this.INIT = INIT;\n    }\n    constructor(actions$, reducer$, scannedActions, initialState) {\n      super(initialState);\n      const actionsOnQueue$ = actions$.pipe(observeOn(queueScheduler));\n      const withLatestReducer$ = actionsOnQueue$.pipe(withLatestFrom(reducer$));\n      const seed = {\n        state: initialState\n      };\n      const stateAndAction$ = withLatestReducer$.pipe(scan(reduceState, seed));\n      this.stateSubscription = stateAndAction$.subscribe(({\n        state,\n        action\n      }) => {\n        this.next(state);\n        scannedActions.next(action);\n      });\n      this.state = toSignal(this, {\n        manualCleanup: true,\n        requireSync: true\n      });\n    }\n    ngOnDestroy() {\n      this.stateSubscription.unsubscribe();\n      this.complete();\n    }\n    /** @nocollapse */\n    static {\n      this.ɵfac = function State_Factory(t) {\n        return new (t || State)(i0.ɵɵinject(ActionsSubject), i0.ɵɵinject(ReducerObservable), i0.ɵɵinject(ScannedActionsSubject), i0.ɵɵinject(INITIAL_STATE));\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n        token: State,\n        factory: State.ɵfac\n      });\n    }\n  }\n  return State;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction reduceState(stateActionPair = {\n  state: undefined\n}, [action, reducer]) {\n  const {\n    state\n  } = stateActionPair;\n  return {\n    state: reducer(state, action),\n    action\n  };\n}\nconst STATE_PROVIDERS = [State, {\n  provide: StateObservable,\n  useExisting: State\n}];\n\n// disabled because we have lowercase generics for `select`\nlet Store = /*#__PURE__*/(() => {\n  class Store extends Observable {\n    constructor(state$, actionsObserver, reducerManager) {\n      super();\n      this.actionsObserver = actionsObserver;\n      this.reducerManager = reducerManager;\n      this.source = state$;\n      this.state = state$.state;\n    }\n    select(pathOrMapFn, ...paths) {\n      return select.call(null, pathOrMapFn, ...paths)(this);\n    }\n    /**\n     * Returns a signal of the provided selector.\n     *\n     * @param selector selector function\n     * @param options select signal options\n     */\n    selectSignal(selector, options) {\n      return computed(() => selector(this.state()), options);\n    }\n    lift(operator) {\n      const store = new Store(this, this.actionsObserver, this.reducerManager);\n      store.operator = operator;\n      return store;\n    }\n    dispatch(action) {\n      this.actionsObserver.next(action);\n    }\n    next(action) {\n      this.actionsObserver.next(action);\n    }\n    error(err) {\n      this.actionsObserver.error(err);\n    }\n    complete() {\n      this.actionsObserver.complete();\n    }\n    addReducer(key, reducer) {\n      this.reducerManager.addReducer(key, reducer);\n    }\n    removeReducer(key) {\n      this.reducerManager.removeReducer(key);\n    }\n    /** @nocollapse */\n    static {\n      this.ɵfac = function Store_Factory(t) {\n        return new (t || Store)(i0.ɵɵinject(StateObservable), i0.ɵɵinject(ActionsSubject), i0.ɵɵinject(ReducerManager));\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n        token: Store,\n        factory: Store.ɵfac\n      });\n    }\n  }\n  return Store;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst STORE_PROVIDERS = [Store];\nfunction select(pathOrMapFn, propsOrPath, ...paths) {\n  return function selectOperator(source$) {\n    let mapped$;\n    if (typeof pathOrMapFn === 'string') {\n      const pathSlices = [propsOrPath, ...paths].filter(Boolean);\n      mapped$ = source$.pipe(pluck(pathOrMapFn, ...pathSlices));\n    } else if (typeof pathOrMapFn === 'function') {\n      mapped$ = source$.pipe(map(source => pathOrMapFn(source, propsOrPath)));\n    } else {\n      throw new TypeError(`Unexpected type '${typeof pathOrMapFn}' in select operator,` + ` expected 'string' or 'function'`);\n    }\n    return mapped$.pipe(distinctUntilChanged());\n  };\n}\nconst RUNTIME_CHECK_URL = 'https://ngrx.io/guide/store/configuration/runtime-checks';\nfunction isUndefined(target) {\n  return target === undefined;\n}\nfunction isNull(target) {\n  return target === null;\n}\nfunction isArray(target) {\n  return Array.isArray(target);\n}\nfunction isString(target) {\n  return typeof target === 'string';\n}\nfunction isBoolean(target) {\n  return typeof target === 'boolean';\n}\nfunction isNumber(target) {\n  return typeof target === 'number';\n}\nfunction isObjectLike(target) {\n  return typeof target === 'object' && target !== null;\n}\nfunction isObject(target) {\n  return isObjectLike(target) && !isArray(target);\n}\nfunction isPlainObject(target) {\n  if (!isObject(target)) {\n    return false;\n  }\n  const targetPrototype = Object.getPrototypeOf(target);\n  return targetPrototype === Object.prototype || targetPrototype === null;\n}\nfunction isFunction(target) {\n  return typeof target === 'function';\n}\nfunction isComponent(target) {\n  return isFunction(target) && target.hasOwnProperty('ɵcmp');\n}\nfunction hasOwnProperty(target, propertyName) {\n  return Object.prototype.hasOwnProperty.call(target, propertyName);\n}\nlet _ngrxMockEnvironment = false;\nfunction setNgrxMockEnvironment(value) {\n  _ngrxMockEnvironment = value;\n}\nfunction isNgrxMockEnvironment() {\n  return _ngrxMockEnvironment;\n}\nfunction isEqualCheck(a, b) {\n  return a === b;\n}\nfunction isArgumentsChanged(args, lastArguments, comparator) {\n  for (let i = 0; i < args.length; i++) {\n    if (!comparator(args[i], lastArguments[i])) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction resultMemoize(projectionFn, isResultEqual) {\n  return defaultMemoize(projectionFn, isEqualCheck, isResultEqual);\n}\nfunction defaultMemoize(projectionFn, isArgumentsEqual = isEqualCheck, isResultEqual = isEqualCheck) {\n  let lastArguments = null;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, , , , ,\n  let lastResult = null;\n  let overrideResult;\n  function reset() {\n    lastArguments = null;\n    lastResult = null;\n  }\n  function setResult(result = undefined) {\n    overrideResult = {\n      result\n    };\n  }\n  function clearResult() {\n    overrideResult = undefined;\n  }\n  /* eslint-disable prefer-rest-params, prefer-spread */\n  // disabled because of the use of `arguments`\n  function memoized() {\n    if (overrideResult !== undefined) {\n      return overrideResult.result;\n    }\n    if (!lastArguments) {\n      lastResult = projectionFn.apply(null, arguments);\n      lastArguments = arguments;\n      return lastResult;\n    }\n    if (!isArgumentsChanged(arguments, lastArguments, isArgumentsEqual)) {\n      return lastResult;\n    }\n    const newResult = projectionFn.apply(null, arguments);\n    lastArguments = arguments;\n    if (isResultEqual(lastResult, newResult)) {\n      return lastResult;\n    }\n    lastResult = newResult;\n    return newResult;\n  }\n  return {\n    memoized,\n    reset,\n    setResult,\n    clearResult\n  };\n}\nfunction createSelector(...input) {\n  return createSelectorFactory(defaultMemoize)(...input);\n}\nfunction defaultStateFn(state, selectors, props, memoizedProjector) {\n  if (props === undefined) {\n    const args = selectors.map(fn => fn(state));\n    return memoizedProjector.memoized.apply(null, args);\n  }\n  const args = selectors.map(fn => fn(state, props));\n  return memoizedProjector.memoized.apply(null, [...args, props]);\n}\n/**\n *\n * @param memoize The function used to memoize selectors\n * @param options Config Object that may include a `stateFn` function defining how to return the selector's value, given the entire `Store`'s state, parent `Selector`s, `Props`, and a `MemoizedProjection`\n *\n * @usageNotes\n *\n * **Creating a Selector Factory Where Array Order Does Not Matter**\n *\n * ```ts\n * function removeMatch(arr: string[], target: string): string[] {\n *   const matchIndex = arr.indexOf(target);\n *   return [...arr.slice(0, matchIndex), ...arr.slice(matchIndex + 1)];\n * }\n *\n * function orderDoesNotMatterComparer(a: any, b: any): boolean {\n *   if (!Array.isArray(a) || !Array.isArray(b)) {\n *     return a === b;\n *   }\n *   if (a.length !== b.length) {\n *     return false;\n *   }\n *   let tempB = [...b];\n *   function reduceToDetermineIfArraysContainSameContents(\n *     previousCallResult: boolean,\n *     arrayMember: any\n *   ): boolean {\n *     if (previousCallResult === false) {\n *       return false;\n *     }\n *     if (tempB.includes(arrayMember)) {\n *       tempB = removeMatch(tempB, arrayMember);\n *       return true;\n *     }\n *     return false;\n *   }\n *   return a.reduce(reduceToDetermineIfArraysContainSameContents, true);\n * }\n *\n * export const createOrderDoesNotMatterSelector = createSelectorFactory(\n *   (projectionFun) => defaultMemoize(\n *     projectionFun,\n *     orderDoesNotMatterComparer,\n *     orderDoesNotMatterComparer\n *   )\n * );\n * ```\n *\n * **Creating an Alternative Memoization Strategy**\n *\n * ```ts\n * function serialize(x: any): string {\n *   return JSON.stringify(x);\n * }\n *\n * export const createFullHistorySelector = createSelectorFactory(\n *  (projectionFunction) => {\n *    const cache = {};\n *\n *    function memoized() {\n *      const serializedArguments = serialize(...arguments);\n *       if (cache[serializedArguments] != null) {\n *         cache[serializedArguments] = projectionFunction.apply(null, arguments);\n *       }\n *       return cache[serializedArguments];\n *     }\n *     return {\n *       memoized,\n *       reset: () => {},\n *       setResult: () => {},\n *       clearResult: () => {},\n *     };\n *   }\n * );\n * ```\n */\nfunction createSelectorFactory(memoize, options = {\n  stateFn: defaultStateFn\n}) {\n  return function (...input) {\n    let args = input;\n    if (Array.isArray(args[0])) {\n      const [head, ...tail] = args;\n      args = [...head, ...tail];\n    } else if (args.length === 1 && isSelectorsDictionary(args[0])) {\n      args = extractArgsFromSelectorsDictionary(args[0]);\n    }\n    const selectors = args.slice(0, args.length - 1);\n    const projector = args[args.length - 1];\n    const memoizedSelectors = selectors.filter(selector => selector.release && typeof selector.release === 'function');\n    const memoizedProjector = memoize(function (...selectors) {\n      return projector.apply(null, selectors);\n    });\n    const memoizedState = defaultMemoize(function (state, props) {\n      return options.stateFn.apply(null, [state, selectors, props, memoizedProjector]);\n    });\n    function release() {\n      memoizedState.reset();\n      memoizedProjector.reset();\n      memoizedSelectors.forEach(selector => selector.release());\n    }\n    return Object.assign(memoizedState.memoized, {\n      release,\n      projector: memoizedProjector.memoized,\n      setResult: memoizedState.setResult,\n      clearResult: memoizedState.clearResult\n    });\n  };\n}\nfunction createFeatureSelector(featureName) {\n  return createSelector(state => {\n    const featureState = state[featureName];\n    if (!isNgrxMockEnvironment() && isDevMode() && !(featureName in state)) {\n      console.warn(`@ngrx/store: The feature name \"${featureName}\" does ` + 'not exist in the state, therefore createFeatureSelector ' + 'cannot access it.  Be sure it is imported in a loaded module ' + `using StoreModule.forRoot('${featureName}', ...) or ` + `StoreModule.forFeature('${featureName}', ...).  If the default ` + 'state is intended to be undefined, as is the case with router ' + 'state, this development-only warning message can be ignored.');\n    }\n    return featureState;\n  }, featureState => featureState);\n}\nfunction isSelectorsDictionary(selectors) {\n  return !!selectors && typeof selectors === 'object' && Object.values(selectors).every(selector => typeof selector === 'function');\n}\nfunction extractArgsFromSelectorsDictionary(selectorsDictionary) {\n  const selectors = Object.values(selectorsDictionary);\n  const resultKeys = Object.keys(selectorsDictionary);\n  const projector = (...selectorResults) => resultKeys.reduce((result, key, index) => ({\n    ...result,\n    [key]: selectorResults[index]\n  }), {});\n  return [...selectors, projector];\n}\n\n/**\n * @description\n * A function that accepts a feature name and a feature reducer, and creates\n * a feature selector and a selector for each feature state property.\n * This function also provides the ability to add extra selectors to\n * the feature object.\n *\n * @param featureConfig An object that contains a feature name and a feature\n * reducer as required, and extra selectors factory as an optional argument.\n * @returns An object that contains a feature name, a feature reducer,\n * a feature selector, a selector for each feature state property, and extra\n * selectors.\n *\n * @usageNotes\n *\n * ```ts\n * interface ProductsState {\n *   products: Product[];\n *   selectedId: string | null;\n * }\n *\n * const initialState: ProductsState = {\n *   products: [],\n *   selectedId: null,\n * };\n *\n * const productsFeature = createFeature({\n *   name: 'products',\n *   reducer: createReducer(\n *     initialState,\n *     on(ProductsApiActions.loadSuccess(state, { products }) => ({\n *       ...state,\n *       products,\n *     }),\n *   ),\n * });\n *\n * const {\n *   name,\n *   reducer,\n *   // feature selector\n *   selectProductsState, // type: MemoizedSelector<Record<string, any>, ProductsState>\n *   // feature state properties selectors\n *   selectProducts, // type: MemoizedSelector<Record<string, any>, Product[]>\n *   selectSelectedId, // type: MemoizedSelector<Record<string, any>, string | null>\n * } = productsFeature;\n * ```\n *\n * **Creating Feature with Extra Selectors**\n *\n * ```ts\n * type CallState = 'init' | 'loading' | 'loaded' | { error: string };\n *\n * interface State extends EntityState<Product> {\n *   callState: CallState;\n * }\n *\n * const adapter = createEntityAdapter<Product>();\n * const initialState: State = adapter.getInitialState({\n *   callState: 'init',\n * });\n *\n * export const productsFeature = createFeature({\n *   name: 'products',\n *   reducer: createReducer(initialState),\n *   extraSelectors: ({ selectProductsState, selectCallState }) => ({\n *     ...adapter.getSelectors(selectProductsState),\n *     ...getCallStateSelectors(selectCallState)\n *   }),\n * });\n *\n * const {\n *   name,\n *   reducer,\n *   // feature selector\n *   selectProductsState,\n *   // feature state properties selectors\n *   selectIds,\n *   selectEntities,\n *   selectCallState,\n *   // selectors returned by `adapter.getSelectors`\n *   selectAll,\n *   selectTotal,\n *   // selectors returned by `getCallStateSelectors`\n *   selectIsLoading,\n *   selectIsLoaded,\n *   selectError,\n * } = productsFeature;\n * ```\n */\nfunction createFeature(featureConfig) {\n  const {\n    name,\n    reducer,\n    extraSelectors: extraSelectorsFactory\n  } = featureConfig;\n  const featureSelector = createFeatureSelector(name);\n  const nestedSelectors = createNestedSelectors(featureSelector, reducer);\n  const baseSelectors = {\n    [`select${capitalize(name)}State`]: featureSelector,\n    ...nestedSelectors\n  };\n  const extraSelectors = extraSelectorsFactory ? extraSelectorsFactory(baseSelectors) : {};\n  return {\n    name,\n    reducer,\n    ...baseSelectors,\n    ...extraSelectors\n  };\n}\nfunction createNestedSelectors(featureSelector, reducer) {\n  const initialState = getInitialState(reducer);\n  const nestedKeys = isPlainObject(initialState) ? Object.keys(initialState) : [];\n  return nestedKeys.reduce((nestedSelectors, nestedKey) => ({\n    ...nestedSelectors,\n    [`select${capitalize(nestedKey)}`]: createSelector(featureSelector, parentState => parentState?.[nestedKey])\n  }), {});\n}\nfunction getInitialState(reducer) {\n  return reducer(undefined, {\n    type: '@ngrx/feature/init'\n  });\n}\nfunction _createStoreReducers(reducers) {\n  return reducers instanceof InjectionToken ? inject(reducers) : reducers;\n}\nfunction _createFeatureStore(configs, featureStores) {\n  return featureStores.map((feat, index) => {\n    if (configs[index] instanceof InjectionToken) {\n      const conf = inject(configs[index]);\n      return {\n        key: feat.key,\n        reducerFactory: conf.reducerFactory ? conf.reducerFactory : combineReducers,\n        metaReducers: conf.metaReducers ? conf.metaReducers : [],\n        initialState: conf.initialState\n      };\n    }\n    return feat;\n  });\n}\nfunction _createFeatureReducers(reducerCollection) {\n  return reducerCollection.map(reducer => {\n    return reducer instanceof InjectionToken ? inject(reducer) : reducer;\n  });\n}\nfunction _initialStateFactory(initialState) {\n  if (typeof initialState === 'function') {\n    return initialState();\n  }\n  return initialState;\n}\nfunction _concatMetaReducers(metaReducers, userProvidedMetaReducers) {\n  return metaReducers.concat(userProvidedMetaReducers);\n}\nfunction _provideForRootGuard() {\n  const store = inject(Store, {\n    optional: true,\n    skipSelf: true\n  });\n  if (store) {\n    throw new TypeError(`The root Store has been provided more than once. Feature modules should provide feature states instead.`);\n  }\n  return 'guarded';\n}\nfunction immutabilityCheckMetaReducer(reducer, checks) {\n  return function (state, action) {\n    const act = checks.action(action) ? freeze(action) : action;\n    const nextState = reducer(state, act);\n    return checks.state() ? freeze(nextState) : nextState;\n  };\n}\nfunction freeze(target) {\n  Object.freeze(target);\n  const targetIsFunction = isFunction(target);\n  Object.getOwnPropertyNames(target).forEach(prop => {\n    // Ignore Ivy properties, ref: https://github.com/ngrx/platform/issues/2109#issuecomment-582689060\n    if (prop.startsWith('ɵ')) {\n      return;\n    }\n    if (hasOwnProperty(target, prop) && (targetIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true)) {\n      const propValue = target[prop];\n      if ((isObjectLike(propValue) || isFunction(propValue)) && !Object.isFrozen(propValue)) {\n        freeze(propValue);\n      }\n    }\n  });\n  return target;\n}\nfunction serializationCheckMetaReducer(reducer, checks) {\n  return function (state, action) {\n    if (checks.action(action)) {\n      const unserializableAction = getUnserializable(action);\n      throwIfUnserializable(unserializableAction, 'action');\n    }\n    const nextState = reducer(state, action);\n    if (checks.state()) {\n      const unserializableState = getUnserializable(nextState);\n      throwIfUnserializable(unserializableState, 'state');\n    }\n    return nextState;\n  };\n}\nfunction getUnserializable(target, path = []) {\n  // Guard against undefined and null, e.g. a reducer that returns undefined\n  if ((isUndefined(target) || isNull(target)) && path.length === 0) {\n    return {\n      path: ['root'],\n      value: target\n    };\n  }\n  const keys = Object.keys(target);\n  return keys.reduce((result, key) => {\n    if (result) {\n      return result;\n    }\n    const value = target[key];\n    // Ignore Ivy components\n    if (isComponent(value)) {\n      return result;\n    }\n    if (isUndefined(value) || isNull(value) || isNumber(value) || isBoolean(value) || isString(value) || isArray(value)) {\n      return false;\n    }\n    if (isPlainObject(value)) {\n      return getUnserializable(value, [...path, key]);\n    }\n    return {\n      path: [...path, key],\n      value\n    };\n  }, false);\n}\nfunction throwIfUnserializable(unserializable, context) {\n  if (unserializable === false) {\n    return;\n  }\n  const unserializablePath = unserializable.path.join('.');\n  const error = new Error(`Detected unserializable ${context} at \"${unserializablePath}\". ${RUNTIME_CHECK_URL}#strict${context}serializability`);\n  error.value = unserializable.value;\n  error.unserializablePath = unserializablePath;\n  throw error;\n}\nfunction inNgZoneAssertMetaReducer(reducer, checks) {\n  return function (state, action) {\n    if (checks.action(action) && !i0.NgZone.isInAngularZone()) {\n      throw new Error(`Action '${action.type}' running outside NgZone. ${RUNTIME_CHECK_URL}#strictactionwithinngzone`);\n    }\n    return reducer(state, action);\n  };\n}\nfunction createActiveRuntimeChecks(runtimeChecks) {\n  if (isDevMode()) {\n    return {\n      strictStateSerializability: false,\n      strictActionSerializability: false,\n      strictStateImmutability: true,\n      strictActionImmutability: true,\n      strictActionWithinNgZone: false,\n      strictActionTypeUniqueness: false,\n      ...runtimeChecks\n    };\n  }\n  return {\n    strictStateSerializability: false,\n    strictActionSerializability: false,\n    strictStateImmutability: false,\n    strictActionImmutability: false,\n    strictActionWithinNgZone: false,\n    strictActionTypeUniqueness: false\n  };\n}\nfunction createSerializationCheckMetaReducer({\n  strictActionSerializability,\n  strictStateSerializability\n}) {\n  return reducer => strictActionSerializability || strictStateSerializability ? serializationCheckMetaReducer(reducer, {\n    action: action => strictActionSerializability && !ignoreNgrxAction(action),\n    state: () => strictStateSerializability\n  }) : reducer;\n}\nfunction createImmutabilityCheckMetaReducer({\n  strictActionImmutability,\n  strictStateImmutability\n}) {\n  return reducer => strictActionImmutability || strictStateImmutability ? immutabilityCheckMetaReducer(reducer, {\n    action: action => strictActionImmutability && !ignoreNgrxAction(action),\n    state: () => strictStateImmutability\n  }) : reducer;\n}\nfunction ignoreNgrxAction(action) {\n  return action.type.startsWith('@ngrx');\n}\nfunction createInNgZoneCheckMetaReducer({\n  strictActionWithinNgZone\n}) {\n  return reducer => strictActionWithinNgZone ? inNgZoneAssertMetaReducer(reducer, {\n    action: action => strictActionWithinNgZone && !ignoreNgrxAction(action)\n  }) : reducer;\n}\nfunction provideRuntimeChecks(runtimeChecks) {\n  return [{\n    provide: _USER_RUNTIME_CHECKS,\n    useValue: runtimeChecks\n  }, {\n    provide: USER_RUNTIME_CHECKS,\n    useFactory: _runtimeChecksFactory,\n    deps: [_USER_RUNTIME_CHECKS]\n  }, {\n    provide: ACTIVE_RUNTIME_CHECKS,\n    deps: [USER_RUNTIME_CHECKS],\n    useFactory: createActiveRuntimeChecks\n  }, {\n    provide: META_REDUCERS,\n    multi: true,\n    deps: [ACTIVE_RUNTIME_CHECKS],\n    useFactory: createImmutabilityCheckMetaReducer\n  }, {\n    provide: META_REDUCERS,\n    multi: true,\n    deps: [ACTIVE_RUNTIME_CHECKS],\n    useFactory: createSerializationCheckMetaReducer\n  }, {\n    provide: META_REDUCERS,\n    multi: true,\n    deps: [ACTIVE_RUNTIME_CHECKS],\n    useFactory: createInNgZoneCheckMetaReducer\n  }];\n}\nfunction checkForActionTypeUniqueness() {\n  return [{\n    provide: _ACTION_TYPE_UNIQUENESS_CHECK,\n    multi: true,\n    deps: [ACTIVE_RUNTIME_CHECKS],\n    useFactory: _actionTypeUniquenessCheck\n  }];\n}\nfunction _runtimeChecksFactory(runtimeChecks) {\n  return runtimeChecks;\n}\nfunction _actionTypeUniquenessCheck(config) {\n  if (!config.strictActionTypeUniqueness) {\n    return;\n  }\n  const duplicates = Object.entries(REGISTERED_ACTION_TYPES).filter(([, registrations]) => registrations > 1).map(([type]) => type);\n  if (duplicates.length) {\n    throw new Error(`Action types are registered more than once, ${duplicates.map(type => `\"${type}\"`).join(', ')}. ${RUNTIME_CHECK_URL}#strictactiontypeuniqueness`);\n  }\n}\n\n/**\n * Provides additional slices of state in the Store.\n * These providers cannot be used at the component level.\n *\n * @usageNotes\n *\n * ### Providing Store Features\n *\n * ```ts\n * const booksRoutes: Route[] = [\n *   {\n *     path: '',\n *     providers: [provideState('books', booksReducer)],\n *     children: [\n *       { path: '', component: BookListComponent },\n *       { path: ':id', component: BookDetailsComponent },\n *     ],\n *   },\n * ];\n * ```\n */\nfunction provideState(featureNameOrSlice, reducers, config = {}) {\n  return makeEnvironmentProviders([..._provideState(featureNameOrSlice, reducers, config), ENVIRONMENT_STATE_PROVIDER]);\n}\nfunction _provideStore(reducers = {}, config = {}) {\n  return [{\n    provide: _ROOT_STORE_GUARD,\n    useFactory: _provideForRootGuard\n  }, {\n    provide: _INITIAL_STATE,\n    useValue: config.initialState\n  }, {\n    provide: INITIAL_STATE,\n    useFactory: _initialStateFactory,\n    deps: [_INITIAL_STATE]\n  }, {\n    provide: _INITIAL_REDUCERS,\n    useValue: reducers\n  }, {\n    provide: _STORE_REDUCERS,\n    useExisting: reducers instanceof InjectionToken ? reducers : _INITIAL_REDUCERS\n  }, {\n    provide: INITIAL_REDUCERS,\n    deps: [_INITIAL_REDUCERS, [new Inject(_STORE_REDUCERS)]],\n    useFactory: _createStoreReducers\n  }, {\n    provide: USER_PROVIDED_META_REDUCERS,\n    useValue: config.metaReducers ? config.metaReducers : []\n  }, {\n    provide: _RESOLVED_META_REDUCERS,\n    deps: [META_REDUCERS, USER_PROVIDED_META_REDUCERS],\n    useFactory: _concatMetaReducers\n  }, {\n    provide: _REDUCER_FACTORY,\n    useValue: config.reducerFactory ? config.reducerFactory : combineReducers\n  }, {\n    provide: REDUCER_FACTORY,\n    deps: [_REDUCER_FACTORY, _RESOLVED_META_REDUCERS],\n    useFactory: createReducerFactory\n  }, ACTIONS_SUBJECT_PROVIDERS, REDUCER_MANAGER_PROVIDERS, SCANNED_ACTIONS_SUBJECT_PROVIDERS, STATE_PROVIDERS, STORE_PROVIDERS, provideRuntimeChecks(config.runtimeChecks), checkForActionTypeUniqueness()];\n}\nfunction rootStoreProviderFactory() {\n  inject(ActionsSubject);\n  inject(ReducerObservable);\n  inject(ScannedActionsSubject);\n  inject(Store);\n  inject(_ROOT_STORE_GUARD, {\n    optional: true\n  });\n  inject(_ACTION_TYPE_UNIQUENESS_CHECK, {\n    optional: true\n  });\n}\n/**\n * Environment Initializer used in the root\n * providers to initialize the Store\n */\nconst ENVIRONMENT_STORE_PROVIDER = [{\n  provide: ROOT_STORE_PROVIDER,\n  useFactory: rootStoreProviderFactory\n}, {\n  provide: ENVIRONMENT_INITIALIZER,\n  multi: true,\n  useFactory() {\n    return () => inject(ROOT_STORE_PROVIDER);\n  }\n}];\n/**\n * Provides the global Store providers and initializes\n * the Store.\n * These providers cannot be used at the component level.\n *\n * @usageNotes\n *\n * ### Providing the Global Store\n *\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [provideStore()],\n * });\n * ```\n */\nfunction provideStore(reducers, config) {\n  return makeEnvironmentProviders([..._provideStore(reducers, config), ENVIRONMENT_STORE_PROVIDER]);\n}\nfunction featureStateProviderFactory() {\n  inject(ROOT_STORE_PROVIDER);\n  const features = inject(_STORE_FEATURES);\n  const featureReducers = inject(FEATURE_REDUCERS);\n  const reducerManager = inject(ReducerManager);\n  inject(_ACTION_TYPE_UNIQUENESS_CHECK, {\n    optional: true\n  });\n  const feats = features.map((feature, index) => {\n    const featureReducerCollection = featureReducers.shift();\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const reducers = featureReducerCollection /*TODO(#823)*/[index];\n    return {\n      ...feature,\n      reducers,\n      initialState: _initialStateFactory(feature.initialState)\n    };\n  });\n  reducerManager.addFeatures(feats);\n}\n/**\n * Environment Initializer used in the feature\n * providers to register state features\n */\nconst ENVIRONMENT_STATE_PROVIDER = [{\n  provide: FEATURE_STATE_PROVIDER,\n  useFactory: featureStateProviderFactory\n}, {\n  provide: ENVIRONMENT_INITIALIZER,\n  multi: true,\n  useFactory() {\n    return () => inject(FEATURE_STATE_PROVIDER);\n  }\n}];\nfunction _provideState(featureNameOrSlice, reducers, config = {}) {\n  return [{\n    provide: _FEATURE_CONFIGS,\n    multi: true,\n    useValue: featureNameOrSlice instanceof Object ? {} : config\n  }, {\n    provide: STORE_FEATURES,\n    multi: true,\n    useValue: {\n      key: featureNameOrSlice instanceof Object ? featureNameOrSlice.name : featureNameOrSlice,\n      reducerFactory: !(config instanceof InjectionToken) && config.reducerFactory ? config.reducerFactory : combineReducers,\n      metaReducers: !(config instanceof InjectionToken) && config.metaReducers ? config.metaReducers : [],\n      initialState: !(config instanceof InjectionToken) && config.initialState ? config.initialState : undefined\n    }\n  }, {\n    provide: _STORE_FEATURES,\n    deps: [_FEATURE_CONFIGS, STORE_FEATURES],\n    useFactory: _createFeatureStore\n  }, {\n    provide: _FEATURE_REDUCERS,\n    multi: true,\n    useValue: featureNameOrSlice instanceof Object ? featureNameOrSlice.reducer : reducers\n  }, {\n    provide: _FEATURE_REDUCERS_TOKEN,\n    multi: true,\n    useExisting: reducers instanceof InjectionToken ? reducers : _FEATURE_REDUCERS\n  }, {\n    provide: FEATURE_REDUCERS,\n    multi: true,\n    deps: [_FEATURE_REDUCERS, [new Inject(_FEATURE_REDUCERS_TOKEN)]],\n    useFactory: _createFeatureReducers\n  }, checkForActionTypeUniqueness()];\n}\nlet StoreRootModule = /*#__PURE__*/(() => {\n  class StoreRootModule {\n    constructor(actions$, reducer$, scannedActions$, store, guard, actionCheck) {}\n    /** @nocollapse */\n    static {\n      this.ɵfac = function StoreRootModule_Factory(t) {\n        return new (t || StoreRootModule)(i0.ɵɵinject(ActionsSubject), i0.ɵɵinject(ReducerObservable), i0.ɵɵinject(ScannedActionsSubject), i0.ɵɵinject(Store), i0.ɵɵinject(_ROOT_STORE_GUARD, 8), i0.ɵɵinject(_ACTION_TYPE_UNIQUENESS_CHECK, 8));\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n        type: StoreRootModule\n      });\n    }\n    /** @nocollapse */\n    static {\n      this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n    }\n  }\n  return StoreRootModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet StoreFeatureModule = /*#__PURE__*/(() => {\n  class StoreFeatureModule {\n    constructor(features, featureReducers, reducerManager, root, actionCheck) {\n      this.features = features;\n      this.featureReducers = featureReducers;\n      this.reducerManager = reducerManager;\n      const feats = features.map((feature, index) => {\n        const featureReducerCollection = featureReducers.shift();\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const reducers = featureReducerCollection /*TODO(#823)*/[index];\n        return {\n          ...feature,\n          reducers,\n          initialState: _initialStateFactory(feature.initialState)\n        };\n      });\n      reducerManager.addFeatures(feats);\n    }\n    // eslint-disable-next-line @angular-eslint/contextual-lifecycle\n    ngOnDestroy() {\n      this.reducerManager.removeFeatures(this.features);\n    }\n    /** @nocollapse */\n    static {\n      this.ɵfac = function StoreFeatureModule_Factory(t) {\n        return new (t || StoreFeatureModule)(i0.ɵɵinject(_STORE_FEATURES), i0.ɵɵinject(FEATURE_REDUCERS), i0.ɵɵinject(ReducerManager), i0.ɵɵinject(StoreRootModule), i0.ɵɵinject(_ACTION_TYPE_UNIQUENESS_CHECK, 8));\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n        type: StoreFeatureModule\n      });\n    }\n    /** @nocollapse */\n    static {\n      this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n    }\n  }\n  return StoreFeatureModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet StoreModule = /*#__PURE__*/(() => {\n  class StoreModule {\n    static forRoot(reducers, config) {\n      return {\n        ngModule: StoreRootModule,\n        providers: [..._provideStore(reducers, config)]\n      };\n    }\n    static forFeature(featureNameOrSlice, reducers, config = {}) {\n      return {\n        ngModule: StoreFeatureModule,\n        providers: [..._provideState(featureNameOrSlice, reducers, config)]\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.ɵfac = function StoreModule_Factory(t) {\n        return new (t || StoreModule)();\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n        type: StoreModule\n      });\n    }\n    /** @nocollapse */\n    static {\n      this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n    }\n  }\n  return StoreModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @description\n * Associates actions with a given state change function.\n * A state change function must be provided as the last parameter.\n *\n * @param args `ActionCreator`'s followed by a state change function.\n *\n * @returns an association of action types with a state change function.\n *\n * @usageNotes\n * ```ts\n * on(AuthApiActions.loginSuccess, (state, { user }) => ({ ...state, user }))\n * ```\n */\nfunction on(...args) {\n  const reducer = args.pop();\n  const types = args.map(creator => creator.type);\n  return {\n    reducer,\n    types\n  };\n}\n/**\n * @description\n * Creates a reducer function to handle state transitions.\n *\n * Reducer creators reduce the explicitness of reducer functions with switch statements.\n *\n * @param initialState Provides a state value if the current state is `undefined`, as it is initially.\n * @param ons Associations between actions and state changes.\n * @returns A reducer function.\n *\n * @usageNotes\n *\n * - Must be used with `ActionCreator`'s (returned by `createAction`). Cannot be used with class-based action creators.\n * - The returned `ActionReducer` does not require being wrapped with another function.\n *\n * **Declaring a reducer creator**\n *\n * ```ts\n * export const reducer = createReducer(\n *   initialState,\n *   on(\n *     featureActions.actionOne,\n *     featureActions.actionTwo,\n *     (state, { updatedValue }) => ({ ...state, prop: updatedValue })\n *   ),\n *   on(featureActions.actionThree, () => initialState);\n * );\n * ```\n */\nfunction createReducer(initialState, ...ons) {\n  const map = new Map();\n  for (const on of ons) {\n    for (const type of on.types) {\n      const existingReducer = map.get(type);\n      if (existingReducer) {\n        const newReducer = (state, action) => on.reducer(existingReducer(state, action), action);\n        map.set(type, newReducer);\n      } else {\n        map.set(type, on.reducer);\n      }\n    }\n  }\n  return function (state = initialState, action) {\n    const reducer = map.get(action.type);\n    return reducer ? reducer(state, action) : state;\n  };\n}\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ACTIVE_RUNTIME_CHECKS, ActionsSubject, FEATURE_REDUCERS, FEATURE_STATE_PROVIDER, INIT, INITIAL_REDUCERS, INITIAL_STATE, META_REDUCERS, REDUCER_FACTORY, ROOT_STORE_PROVIDER, ReducerManager, ReducerManagerDispatcher, ReducerObservable, STORE_FEATURES, ScannedActionsSubject, State, StateObservable, Store, StoreFeatureModule, StoreModule, StoreRootModule, UPDATE, USER_PROVIDED_META_REDUCERS, USER_RUNTIME_CHECKS, combineReducers, compose, createAction, createActionGroup, createFeature, createFeatureSelector, createReducer, createReducerFactory, createSelector, createSelectorFactory, defaultMemoize, defaultStateFn, emptyProps, isNgrxMockEnvironment, on, props, provideState, provideStore, reduceState, resultMemoize, select, setNgrxMockEnvironment, union };\n","import { createAction, createFeatureSelector, createSelector, props } from '@ngrx/store';\nimport { AppState } from './models';\n\nexport const goBack = createAction('[Coordinator] Go Back');\nexport const addNew = createAction('[Coordinator] Add New', props<{ newCoordinator: any }>());\nexport const resetState = createAction('[Coordinator] Reset State');\n\nexport const selectAppState = createFeatureSelector<AppState>('appState');\nexport const selectCurrentCoordinator = createSelector(selectAppState, (state) => state.currentValues);\nexport const selectPastStates = createSelector(selectAppState, (state) => state.past);\n"],"mappings":"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","names":["toSignal","source","options","requiresCleanup","assertInInjectionContext","cleanupRef","DestroyRef","inject","state","signal","sub","value","error","computed","current","RuntimeError","REGISTERED_ACTION_TYPES","createAction","type","config","REGISTERED_ACTION_TYPES","defineType","args","__spreadProps","__spreadValues","props","defineType","type","creator","INIT","ActionsSubject","_ActionsSubject","BehaviorSubject","action","t","ɵɵdefineInjectable","ACTIONS_SUBJECT_PROVIDERS","_ROOT_STORE_GUARD","InjectionToken","_INITIAL_STATE","INITIAL_STATE","REDUCER_FACTORY","_REDUCER_FACTORY","INITIAL_REDUCERS","_INITIAL_REDUCERS","STORE_FEATURES","_STORE_REDUCERS","_FEATURE_REDUCERS","_FEATURE_CONFIGS","_STORE_FEATURES","_FEATURE_REDUCERS_TOKEN","FEATURE_REDUCERS","USER_PROVIDED_META_REDUCERS","META_REDUCERS","_RESOLVED_META_REDUCERS","USER_RUNTIME_CHECKS","_USER_RUNTIME_CHECKS","ACTIVE_RUNTIME_CHECKS","_ACTION_TYPE_UNIQUENESS_CHECK","ROOT_STORE_PROVIDER","FEATURE_STATE_PROVIDER","combineReducers","reducers","initialState","reducerKeys","finalReducers","key","finalReducerKeys","state","hasChanged","nextState","i","reducer","previousStateForKey","nextStateForKey","omit","object","keyToRemove","result","compose","functions","arg","last","composed","fn","createReducerFactory","reducerFactory","metaReducers","createFeatureReducerFactory","r","ReducerObservable","Observable","ReducerManagerDispatcher","UPDATE","ReducerManager","_ReducerManager","dispatcher","feature","features","reducerDict","p","__spreadValues","featureKey","featureKeys","ɵɵinject","REDUCER_MANAGER_PROVIDERS","ScannedActionsSubject","_ScannedActionsSubject","Subject","ɵScannedActionsSubject_BaseFactory","ɵɵgetInheritedFactory","SCANNED_ACTIONS_SUBJECT_PROVIDERS","StateObservable","State","_State","actions$","reducer$","scannedActions","withLatestReducer$","observeOn","queueScheduler","withLatestFrom","seed","stateAndAction$","scan","reduceState","toSignal","stateActionPair","STATE_PROVIDERS","Store","_Store","state$","actionsObserver","reducerManager","pathOrMapFn","paths","select","selector","options","computed","operator","store","err","STORE_PROVIDERS","propsOrPath","source$","mapped$","pathSlices","pluck","map","source","distinctUntilChanged","RUNTIME_CHECK_URL","isUndefined","target","isNull","isArray","isString","isBoolean","isNumber","isObjectLike","isObject","isPlainObject","targetPrototype","isFunction","isComponent","hasOwnProperty","propertyName","_ngrxMockEnvironment","isNgrxMockEnvironment","_ngrxMockEnvironment","isEqualCheck","a","b","isArgumentsChanged","args","lastArguments","comparator","i","defaultMemoize","projectionFn","isArgumentsEqual","isEqualCheck","isResultEqual","lastArguments","lastResult","overrideResult","reset","setResult","result","clearResult","memoized","isArgumentsChanged","newResult","createSelector","input","createSelectorFactory","defaultStateFn","state","selectors","props","memoizedProjector","args","fn","memoize","options","head","tail","isSelectorsDictionary","extractArgsFromSelectorsDictionary","projector","memoizedSelectors","selector","memoizedState","release","createFeatureSelector","featureName","featureState","isNgrxMockEnvironment","isDevMode","selectorsDictionary","resultKeys","selectorResults","key","index","__spreadProps","__spreadValues","_createStoreReducers","reducers","InjectionToken","inject","_initialStateFactory","initialState","_concatMetaReducers","metaReducers","userProvidedMetaReducers","_provideForRootGuard","inject","Store","immutabilityCheckMetaReducer","reducer","checks","state","action","act","freeze","nextState","target","targetIsFunction","isFunction","prop","hasOwnProperty","propValue","isObjectLike","serializationCheckMetaReducer","unserializableAction","getUnserializable","throwIfUnserializable","unserializableState","path","isUndefined","isNull","result","key","value","isComponent","isNumber","isBoolean","isString","isArray","isPlainObject","unserializable","context","unserializablePath","error","RUNTIME_CHECK_URL","inNgZoneAssertMetaReducer","NgZone","createActiveRuntimeChecks","runtimeChecks","isDevMode","__spreadValues","createSerializationCheckMetaReducer","strictActionSerializability","strictStateSerializability","ignoreNgrxAction","createImmutabilityCheckMetaReducer","strictActionImmutability","strictStateImmutability","createInNgZoneCheckMetaReducer","strictActionWithinNgZone","provideRuntimeChecks","_USER_RUNTIME_CHECKS","USER_RUNTIME_CHECKS","_runtimeChecksFactory","ACTIVE_RUNTIME_CHECKS","META_REDUCERS","checkForActionTypeUniqueness","_ACTION_TYPE_UNIQUENESS_CHECK","_actionTypeUniquenessCheck","config","duplicates","REGISTERED_ACTION_TYPES","registrations","type","_provideStore","reducers","config","_ROOT_STORE_GUARD","_provideForRootGuard","_INITIAL_STATE","INITIAL_STATE","_initialStateFactory","_INITIAL_REDUCERS","_STORE_REDUCERS","InjectionToken","INITIAL_REDUCERS","Inject","_createStoreReducers","USER_PROVIDED_META_REDUCERS","_RESOLVED_META_REDUCERS","META_REDUCERS","_concatMetaReducers","_REDUCER_FACTORY","combineReducers","REDUCER_FACTORY","createReducerFactory","ACTIONS_SUBJECT_PROVIDERS","REDUCER_MANAGER_PROVIDERS","SCANNED_ACTIONS_SUBJECT_PROVIDERS","STATE_PROVIDERS","STORE_PROVIDERS","provideRuntimeChecks","checkForActionTypeUniqueness","rootStoreProviderFactory","inject","ActionsSubject","ReducerObservable","ScannedActionsSubject","Store","_ACTION_TYPE_UNIQUENESS_CHECK","ENVIRONMENT_STORE_PROVIDER","ROOT_STORE_PROVIDER","ENVIRONMENT_INITIALIZER","provideStore","makeEnvironmentProviders","on","args","reducer","types","creator","createReducer","initialState","ons","map","type","existingReducer","newReducer","state","action","goBack","createAction","addNew","props","resetState","selectAppState","createFeatureSelector","selectCurrentCoordinator","createSelector","state","currentValues","selectPastStates","past"],"x_google_ignoreList":[0,1]}